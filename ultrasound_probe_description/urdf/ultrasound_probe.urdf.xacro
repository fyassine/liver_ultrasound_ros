<?xml version="1.0"?>

<!-- Ultrasound probe attached to iiwa7 robot -->
<robot xmlns:xacro="http://www.ros.org/wiki/xacro" name="iiwa7_ultrasound_probe">
  
  <!-- Import Rviz colors -->
  <xacro:include filename="$(find iiwa_description)/urdf/materials.xacro" />
  <!--Import the iiwa7 macro -->
  <xacro:include filename="$(find iiwa_description)/urdf/iiwa7.xacro"/>
  
  <!--  Arguments for the iiwa7 macro  -->
  <xacro:arg name="hardware_interface" default="PositionJointInterface"/>
  <xacro:arg name="robot_name" default="iiwa"/>
  
  <!-- Ultrasound probe properties -->
  <xacro:property name="probe_mass" value="0.300" />
  <xacro:property name="probe_length" value="0.24" />
  
  <!-- Camera properties -->
  <xacro:property name="camera_mass" value="0.072" />
  <xacro:property name="PI" value="3.14159265359" />
  
  <!-- Force-torque sensor properties -->
  <xacro:property name="ft_sensor_mass" value="0.120" />
  <xacro:property name="ft_sensor_radius" value="0.03" />
  <xacro:property name="ft_sensor_thickness" value="0.015" />
  <xacro:property name="ft_sensor_ixx"
                  value="${(1.0/12.0) * ft_sensor_mass * (3 * ft_sensor_radius * ft_sensor_radius + ft_sensor_thickness * ft_sensor_thickness)}" />
  <xacro:property name="ft_sensor_izz"
                  value="${0.5 * ft_sensor_mass * ft_sensor_radius * ft_sensor_radius}" />
  
  <!-- Fix to world -->
  <link name="world"/>
  
  <!-- Insert iiwa7 robot in the scene -->
  <xacro:iiwa7 hardware_interface="$(arg hardware_interface)" robot_name="$(arg robot_name)" parent="world">
    <origin xyz="0 0 0" rpy="0 0 0" />
  </xacro:iiwa7>
  
  <!--  Joint between the tip of the iiwa7 and the force-torque sensor -->
  <!-- Use revolute with zero limits to enable F/T sensor plugin -->
  <joint name="ft_sensor_joint" type="revolute">
    <parent link="iiwa_link_ee" />
    <child link="ft_sensor_link" />
    <origin xyz="0 0 0" rpy="0 0 0" />
    <axis xyz="0 0 1"/>
    <limit lower="0" upper="0" effort="0" velocity="0"/>
  </joint>

  <!-- Merged F/T sensor + probe into single rigid body for force transmission -->
  <link name="ft_sensor_link">
    <!-- F/T sensor visual (small disk) -->
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <cylinder length="${ft_sensor_thickness}" radius="${ft_sensor_radius}"/>
      </geometry>
      <material name="Grey"/>
    </visual>
    
    <!-- Probe visual (offset to account for sensor thickness) -->
    <visual>
      <origin xyz="0 0 ${ft_sensor_thickness/2 - 0.107}" rpy="0 0 0"/>
      <geometry>
        <mesh filename="package://ultrasound_probe_description/meshes/visual/iiwa_ultrasound_probe.dae"/>
      </geometry>
      <material name="Grey"/>
    </visual>
    
    <!-- Collision for entire assembly (use probe mesh for contact) -->
    <collision>
      <origin xyz="0 0 ${ft_sensor_thickness/2 - 0.107}" rpy="0 0 0"/>
      <geometry>
        <mesh filename="package://ultrasound_probe_description/meshes/collision/iiwa_ultrasound_probe.dae"/>
      </geometry>
    </collision>
    
    <!-- Combined inertia (sensor + probe mass) -->
    <inertial>
      <origin xyz="0 0 ${ft_sensor_thickness/2 + 0.15}" rpy="0 0 0"/>
      <mass value="${ft_sensor_mass + probe_mass}"/>
      <inertia ixx="0.002" ixy="0" ixz="0"
               iyy="0.002" iyz="0"
               izz="0.001"/>
    </inertial>
  </link>
  
  <!--  TCP frame at probe tip (relative to sensor link) -->
  <joint name="probe_ee_joint" type="fixed">
    <parent link="ft_sensor_link" />
    <child link="probe_link_ee" />
    <origin xyz="0 0 ${ft_sensor_thickness/2 + probe_length}" rpy="0 0 0" />   
  </joint>
  
  <!--  The TCP frame -->
  <link name="probe_link_ee">
    <visual>
      <origin rpy="0.0 0.0 0.0" xyz="0 0 0.0"/>
      <geometry>
        <cylinder length="0.0001" radius="0.0001" />
      </geometry>
    </visual>
    <collision>
      <origin rpy="0.0 0.0 0.0" xyz="0 0 0.0"/>
      <geometry>
        <cylinder length="0.0001" radius="0.0001" />
      </geometry>
    </collision>
  </link>

  <!-- Transmission for the force-torque sensor joint to expose it to ros_control -->
  <transmission name="ft_sensor_joint_transmission">
    <type>transmission_interface/SimpleTransmission</type>
    <actuator name="ft_sensor_actuator">
      <mechanicalReduction>1.0</mechanicalReduction>
    </actuator>
    <joint name="ft_sensor_joint">
      <hardwareInterface>hardware_interface/PositionJointInterface</hardwareInterface>
    </joint>
  </transmission>

  <!-- Gazebo plugin to expose the simulated force-torque readings -->
  <gazebo>
    <plugin name="wrist_ft_sensor_plugin" filename="libgazebo_ros_ft_sensor.so">
      <updateRate>100.0</updateRate>
      <topicName>/$(arg robot_name)/ft_sensor/wrench</topicName>
      <jointName>ft_sensor_joint</jointName>
    </plugin>
  </gazebo>

  <!-- Wrist-mounted RGB-D Camera -->
  <!-- Joint to mount camera on the side of the sensor/probe assembly -->
  <joint name="wrist_camera_joint" type="fixed">
    <parent link="ft_sensor_link" />
    <child link="wrist_camera_link" />
    <!-- Adjust Z offset to account for sensor thickness -->
    <origin xyz="0.07 0.07 ${ft_sensor_thickness/2 + 0.0725}" rpy="0 ${-PI/2} -0.75" />
  </joint>

  <link name="wrist_camera_link">
    <visual>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <box size="0.05 0.05 0.05"/> <!-- Small 5cm cube -->
      </geometry>
      <material name="Blue">
        <color rgba="0 0 1 1"/>
      </material>
    </visual>
    <collision>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <geometry>
        <box size="0.05 0.05 0.05"/>
      </geometry>
    </collision>
    <inertial>
      <origin xyz="0 0 0" rpy="0 0 0"/>
      <mass value="${camera_mass}"/>
      <inertia ixx="0.00001" ixy="0.0" ixz="0.0" iyy="0.00001" iyz="0.0" izz="0.00001"/>
    </inertial>
  </link>

  <!-- Camera optical frame (standard ROS camera convention) -->
  <joint name="wrist_camera_optical_joint" type="fixed">
    <parent link="wrist_camera_link" />
    <child link="wrist_camera_optical_frame" />
    <!-- Transform from camera link to optical frame: rotate to ROS camera convention -->
    <!-- X forward, Y left, Z up in optical frame -->
    <origin xyz="0 0 0" rpy="${-PI/2} 0 ${-PI/2}" />
  </joint>

  <link name="wrist_camera_optical_frame"/>

  <!-- Gazebo visual appearance for camera - small blue cube -->
  <gazebo reference="wrist_camera_link">
    <visual>
      <geometry>
        <box>
          <size>0.05 0.05 0.05</size>
        </box>
      </geometry>
      <material>
        <ambient>0 0 1 1</ambient>
        <diffuse>0 0 1 1</diffuse>
        <specular>0.1 0.1 0.1 1</specular>
      </material>
    </visual>
  </gazebo>

  <!-- Gazebo plugin for RGB-D camera -->
  <gazebo reference="wrist_camera_link">
    <sensor name="wrist_rgbd_camera" type="depth">
      <camera name="wrist_camera">
        <horizontal_fov>1.211</horizontal_fov> <!-- ~69 degrees, typical for D435 -->
        <image>
          <width>640</width>
          <height>480</height>
          <format>R8G8B8</format>
        </image>
        <clip>
          <near>0.1</near>
          <far>10.0</far>
        </clip>
        <distortion>
          <k1>0.0</k1>
          <k2>0.0</k2>
          <k3>0.0</k3>
          <p1>0.0</p1>
          <p2>0.0</p2>
          <center>0.5 0.5</center>
        </distortion>
      </camera>
      <always_on>1</always_on>
      <update_rate>30</update_rate>
      <visualize>false</visualize>
      <plugin name="wrist_camera_controller" filename="libgazebo_ros_openni_kinect.so">
        <robotNamespace>/$(arg robot_name)</robotNamespace>
        <alwaysOn>true</alwaysOn>
        <updateRate>30.0</updateRate>
        <cameraName>wrist_camera</cameraName>
        <imageTopicName>rgb/image_raw</imageTopicName>
        <cameraInfoTopicName>rgb/camera_info</cameraInfoTopicName>
        <depthImageTopicName>depth/image_raw</depthImageTopicName>
        <depthImageCameraInfoTopicName>depth/camera_info</depthImageCameraInfoTopicName>
        <pointCloudTopicName>depth/points</pointCloudTopicName>
        <frameName>wrist_camera_optical_frame</frameName>
        <distortionK1>0.0</distortionK1>
        <distortionK2>0.0</distortionK2>
        <distortionK3>0.0</distortionK3>
        <distortionT1>0.0</distortionT1>
        <distortionT2>0.0</distortionT2>
        <pointCloudCutoff>0.02</pointCloudCutoff>
        <pointCloudCutoffMax>5.0</pointCloudCutoffMax>
      </plugin>
    </sensor>
  </gazebo>

</robot>
